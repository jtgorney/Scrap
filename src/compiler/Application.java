/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Matt Mossner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package compiler;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * This class represents an application that can be run.
 *
 * @author Matthew Mossner
 */
public class Application {

   private final List<String> command;

   /**
    * Constructs a new Application with the specified program and arguments.
    *
    * @param executable The application's executable file
    * @param arguments Arguments supplied to the executable
    */
   public Application(File executable, String... arguments) {
      command = new ArrayList<>(Arrays.asList(arguments));
      command.add(0, executable.getAbsolutePath());
   }

   /**
    * Runs the application.
    *
    * @param workingDirectory A File representing the working directory of the
    * application; if null, the application will run in the working directory of
    * the calling process
    * @param stdInput A File containing the standard input provided to the
    * application; if null, no standard input will be provided
    * @param timeout The maximum amount of time, in seconds, to wait for the
    * application to finish executing
    * @param arguments Additional arguments to be provided to the application;
    * empty arguments will be ignored.
    * @return A File array with the first file containing standard output
    * generated by resulting process, if any, and the second file containing any
    * standard error generated.
    * @throws java.io.IOException If the application's executable, working
    * directory, or standard input file is invalid, or if the standard
    * output/error files could not be created
    * @throws compiler.ApplicationTimeoutException If the application is
    * terminated as the result of a timeout.
    */
   public File[] run(File workingDirectory, File stdInput,
                     long timeout, String... arguments)
           throws InterruptedException, IOException {
      if (arguments != null) {
         ArrayList<String> argumentList =
                 new ArrayList<>(Arrays.asList(arguments));
         while (argumentList.contains(""))
            argumentList.remove("");
         command.addAll(argumentList);
      }
      ProcessBuilder pb = new ProcessBuilder(command);
      File[] output = new File[2];
      output[0] = File.createTempFile(System.currentTimeMillis() + "",
                                      ".stdout");
      output[1] = File.createTempFile(System.currentTimeMillis() + "",
                                      ".stderr");
      output[0].deleteOnExit();
      output[1].deleteOnExit();
      pb.redirectOutput(output[0]);
      pb.redirectError(output[1]);
      if (stdInput != null)
         pb.redirectInput(stdInput);
      pb.directory(workingDirectory);
      Process p = pb.start();
      if (timeout > 0) {
         p.waitFor(timeout, TimeUnit.SECONDS);
         if (p.isAlive()) {
            p.destroy();
            throw new ApplicationTimeoutException(timeout, TimeUnit.SECONDS);
         }
      }
      else {
         p.waitFor();
      }
      return output;
   }
}
