/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jacob Gorney, Max Savard, Matt Mossner, Spencer Kokaly
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package compiler;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

/**
 * This class is used to process source code files into applications, run them
 * with desired input, and return the results.  Source code files, and their
 * respective inputs, are initially queued using either of the add methods. When
 * the process method is called, each source code file is processed and run with
 * its provided input data in the order in which they were added.  New data
 * cannot be added while source code files are being processed.  Results for
 * each individual application are written to a file, and stored in an output
 * queue.  The output files can be retrieved by calling the getNextResult method
 * or getResults method.  If an exception occurs during processing, the source
 * code file that was being processed will remain at the front of the queue,
 * along with its provided input data.  Files can be removed from the processing
 * queue by calling removeNext, removeLast, or removeAll, as long as source code
 * files are not currently being processed.
 * <p>
 * A result file can consist of multiple headers, each on its own line  Headers
 * are defined as public constants, and are followed by an optional body; the
 * end of the header body is delimited by the header's ending tag, also defined
 * as a public constant, on a new line.  All result files begin with a status
 * header.  There are four status headers: RUN_OK, TIMEOUT, COMPILER_ERROR, and
 * UNSUPPORTED_LANGUAGE.  The RUN_OK header indicates that an application ran
 * successfully to natural termination.  The TIMEOUT header indicates that the
 * application exceeded its permitted execution time, and was forcibly
 * terminated.  The COMPILER_ERROR header indicates that the code failed to
 * compile.  The UNSUPPORTED_LANGUAGE header indicates that the file extension
 * of the source code file was unrecognized.  The TIMEOUT header has no body.
 * The UNSUPPORTED_LANGUAGE header has a single-line body consisting of the file
 * extension of the provided source code file.  The COMPILER_ERROR body consists
 * of output generated by the compiler.  The OK body consists of output
 * generated by each run of the application.  Process output is delimited by the
 * BEGIN_OUTPUT header.  The body of the output header consists of both standard
 * output and standard error generated by the process.  Standard output and
 * standard error are represented by lines beginning with a semicolon, and are
 * enclosed within their respective header and end tags.  The end of a set of
 * output is marked by the END_OUTPUT tag.  The end of a file is marked by the
 * END_FILE tag.
 *
 * @author Matthew Mossner
 */
public class CodeProcessor {

   public static final String RUN_OK = "OK";
   public static final String TIMEOUT = "APPLICATION TIMEOUT";
   public static final String COMPILER_ERROR = "COMPILE ERROR";
   public static final String UNSUPPORTED_LANGUAGE = "UNSUPPORTED LANGUAGE";
   public static final String BEGIN_OUTPUT = "BEGIN OUTPUT";
   public static final String END_OUTPUT = "END OUTPUT";
   public static final String BEGIN_STD_OUT = "BEGIN STANDARD OUTPUT";
   public static final String END_STD_OUT = "END STANDARD OUTPUT";
   public static final String BEGIN_STD_ERR = "BEGIN STANDARD ERROR";
   public static final String END_STD_ERR = "END STANDARD ERROR";
   public static final String BEGIN_CODE = "BEGIN CODE";
   public static final String END_CODE = "END CODE";
   public static final String END_FILE = "END FILE";

   public static final int TIMEOUT_DURATION = 30;

   private static CodeProcessor instance;

   private final ArrayDeque<File[]> input;
   private final ArrayDeque<File> output;
   private final HashMap<String, ApplicationBuilder> applicationBuilders;
   private boolean processing;

   /**
    * Constructs a CodeProcessor.
    */
   private CodeProcessor() {
      processing = false;
      input = new ArrayDeque<>();
      output = new ArrayDeque<>();

      applicationBuilders = new HashMap<>();
      applicationBuilders.put(".java", JavaApplicationBuilder.getInstance());
      applicationBuilders.put(".cpp", CPPApplicationBuilder.getInstance());
   }

   /**
    * Add a set of source code and input to the processing queue, if not
    * currently processing.
    *
    * @param codeFileAndInput A File array beginning with a source code file and
    * optionally followed by input files
    * @return true if the data was added to the queue; false otherwise
    */
   public boolean add(File[] codeFileAndInput) {
      return !processing && input.add(codeFileAndInput);
   }

   /**
    * Adds multiple sets of source code and input to the processing queue, if
    * not currently processing.
    *
    * @param codeFilesAndInputs An array of File arrays, with each File array
    * beginning with a source code file and optionally followed by input files
    * @return true if the data was added to the queue; false otherwise
    */
   public boolean add(File[][] codeFilesAndInputs) {
      if (!processing && codeFilesAndInputs.length >= 1) {
         Collections.addAll(input, codeFilesAndInputs);
         return true;
      }

      return false;
   }

   /**
    * Removes the least recently added data from the processing queue if not
    * currently processing.
    *
    * @return true if the data was removed; false otherwise
    */
   public boolean removeNextRemaining() {
      if (!processing) {
         input.removeFirst();
         return true;
      }
      return false;
   }

   /**
    * Removes the most recently added data from the processing queue if not
    * currently processing.
    *
    * @return true if the data was removed; false otherwise
    */
   public boolean removeLastRemaining() {
      if (!processing) {
         input.removeLast();
         return true;
      }
      return false;
   }

   /**
    * Removes all data from the processing queue if not currently processing.
    *
    * @return true if the data was removed; false otherwise
    */
   public boolean removeAllRemaining() {
      if (!processing) {
         input.clear();
         return true;
      }
      return false;
   }

   /**
    * @return true if source code is currently being processed; false otherwise
    */
   public boolean isProcessing() {
      return processing;
   }

   /**
    * @return True if there are still files to be processed; false otherwise
    */
   public boolean hasRemaining() {
      return (!input.isEmpty());
   }

   /**
    * @return True if there is at least one result file that can be retrieved;
    * false otherwise
    */
   public boolean hasResult() {
      return (!output.isEmpty());
   }

   /**
    * @return A File array representing the least recently added code/input set
    * that has yet to be processed.
    */
   public File[] getNextRemaining() {
      return input.getFirst();
   }

   /**
    * @return A File array representing the most recently added code/input set
    * that has yet to be processed.
    */
   public File[] getLastRemaining() {
      return input.getLast();
   }

   /**
    * @return An array of File arrays, with each File array representing the
    * code/input sets that have yet to be processed.
    */
   public File[][] getAllRemaining() {
      return input.toArray(new File[][]{});
   }

   /**
    * Retrieves and removes the result file for the most recent set of code and
    * input processed.
    *
    * @return The result file for the most recent set of code and input
    * processed
    */
   public File getResult() {
      return output.removeFirst();
   }

   /**
    * Retrieves and removes the result files for each set of code and input
    * processed.
    *
    * @return A File array containing a result file for each set of code and
    * input processed.
    */
   public File[] getResults() {
      File[] results = output.toArray(new File[output.size()]);
      output.clear();
      return results;
   }

   /**
    * Attempts to process and run all code files in the queue with their
    * respective inputs, if any.
    */
   public void process() throws InterruptedException, IOException {
      processing = true;
      while (!input.isEmpty()) {
         PrintStream writer = null;
         File[] codeFileAndInput = input.getFirst();
         File runResult = null;
         try {
            runResult =
                    new File(FileUtils.removeFileExtension(codeFileAndInput[0])
                             + ".out");
            String extension = FileUtils.fileExtension(codeFileAndInput[0]);
            ApplicationBuilder builder = applicationBuilders.get(extension);
            Application app;
            runResult.createNewFile();
            runResult.deleteOnExit();
            writer = new PrintStream(runResult);
            if (builder != null) {
               // There is an ApplicationBuilder for this file extension
               app = builder.getApplication(codeFileAndInput[0]);
               if (app != null) {  // There was no compiler error
                  writer.println(RUN_OK);
                  if (codeFileAndInput.length > 1) {  // Input data provided
                     for (int i = 1; i < codeFileAndInput.length; i++) {
                        appendOutput(writer, app.run(null, codeFileAndInput[i],
                                                     TIMEOUT_DURATION));
                     }
                  }
                  else  // No input data provided
                     appendOutput(writer, app.run(null, null,
                                                  TIMEOUT_DURATION));
                  if (builder instanceof CompiledApplicationBuilder) {
                     CompiledApplicationBuilder castedBuilder =
                             (CompiledApplicationBuilder) builder;
                     castedBuilder.getCompiledCode().delete();
                  }
               }
               else {  // There was a compiler error
                  CompiledApplicationBuilder castedBuilder =
                          (CompiledApplicationBuilder) builder;
                  writer.println(COMPILER_ERROR);
                  appendOutput(writer, castedBuilder.getCompilerOutput());
               }
            }
            else  // There is no ApplicationBuilder for this file extension
            {
               writer.println(UNSUPPORTED_LANGUAGE);
               writer.println(extension);
            }
            appendCode(writer, codeFileAndInput[0]);
            writer.print(END_FILE);
         }
         catch (NullPointerException | InterruptedException | IOException e) {
            processing = false;
            throw e;
         }
         catch (ApplicationTimeoutException e) {
            writer.close();
            writer = new PrintStream(runResult);
            writer.println(TIMEOUT);
            appendCode(writer, codeFileAndInput[0]);
            writer.print(END_FILE);
         }
         finally {
            if (writer != null)
               writer.close();
         }
         output.add(runResult);
         input.removeFirst();
         codeFileAndInput[0].delete();
      }
      processing = false;
   }

   /**
    * @return An instance of CodeProcessor
    */
   public static CodeProcessor getInstance() {
      if (instance == null)
         instance = new CodeProcessor();
      return instance;
   }

   /**
    * Appends the provided standard output/error files' contents, with
    * corresponding headers, to the provided master file using the provided
    * PrintStream.
    *
    * @param writer A PrintStream associated with the file to append to
    * @param appendedOutput A File array with the first file containing standard
    * output generated by a process, and the second file containing standard
    * error generated by said process
    */
   private static void appendOutput(PrintStream writer, File[] appendedOutput)
           throws FileNotFoundException {
      writer.println(BEGIN_OUTPUT);
      writer.println(BEGIN_STD_OUT);
      Scanner s = new Scanner(appendedOutput[0]);
      while (s.hasNextLine()) {
         writer.println(";" + s.nextLine());
      }
      s.close();
      writer.println(END_STD_OUT);
      writer.println(BEGIN_STD_ERR);
      s = new Scanner(appendedOutput[1]);
      while (s.hasNextLine()) {
         writer.println(";" + s.nextLine());
      }
      s.close();
      writer.println(END_STD_ERR);
      writer.println(END_OUTPUT);
   }
   
   private static void appendCode(PrintStream writer, File codeFile) 
           throws FileNotFoundException {
       writer.println(BEGIN_CODE);
       Scanner s = new Scanner(codeFile);
       while (s.hasNextLine()) {
           writer.println(s.nextLine());
       }
       s.close();
       writer.println(END_CODE);
   }
}
